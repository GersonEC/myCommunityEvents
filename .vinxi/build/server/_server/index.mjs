import{defaultTransformer as h,createFileRoute as w,lazyRouteComponent as p}from"@tanstack/react-router";import y from"tiny-invariant";import{PrismaClient as m}from"@prisma/client";function x(e,t,n){return Object.assign(e,{url:"https://localhost:3000"})}function g(e){return e instanceof Headers?new Headers(e):Array.isArray(e)?new Headers(e):typeof e=="object"?new Headers(e):new Headers}function _(...e){return e.reduce((t,n)=>{const r=g(n);for(const[a,o]of r.entries())t.set(a,o);return t},new Headers)}function l(e,t){const n=t||e||{};return typeof n.method>"u"&&(n.method="GET"),{options:n,middleware:r=>l(void 0,Object.assign(n,{middleware:r})),validator:r=>l(void 0,Object.assign(n,{validator:r})),handler:(...r)=>{const[a,o]=r;Object.assign(n,{...a,extractedFn:a,serverFn:o}),y(a.url,"createServerFn must be called with a function that is marked with the 'use server' pragma. Are you using the @tanstack/start-vite-plugin ?");const s=[...n.middleware||[],T(n)];return Object.assign(async i=>f(s,"client",{...a,method:n.method,data:i?.data,headers:i?.headers,context:Object.assign({},a)}).then(d=>d.result),{...a,__executeServer:i=>{const d=i instanceof FormData?F(i):i;return f(s,"server",{...a,...d}).then(c=>({result:c.result,context:c.sendContext}))}})}}}function F(e){const t=e.get("__TSR_CONTEXT");if(e.delete("__TSR_CONTEXT"),typeof t!="string")return{context:{},data:e};try{return{context:h.parse(t),data:e}}catch{return{data:e}}}function O(e){const t=[],n=r=>{r.forEach(a=>{a.options.middleware&&n(a.options.middleware),t.push(a)})};return n(e),t}const u=(e,t,n)=>e({data:t.data,context:t.context,sendContext:t.sendContext,method:t.method,next:r=>{const a={...t.context,...r?.context},o={...t.sendContext,...r?.sendContext??{}},s=_(t.headers,r?.headers);return n({method:t.method,data:t.data,context:a,sendContext:o,headers:s,result:r?.result??t.result})}});function b(e,t){if(e==null)return{};if("~standard"in e){const n=e["~standard"].validate(t);if("value"in n)return n.value;throw n instanceof Promise?new Error("Async validation not supported"):new Error(JSON.stringify(n.issues,void 0,2))}if("parse"in e)return e.parse(t);if(typeof e=="function")return e(t);throw new Error("Invalid validator type!")}async function f(e,t,n){const r=O(e),a=async o=>{const s=r.shift();if(!s)return o;s.options.validator&&(t!=="client"||s.options.validateClient)&&(o.data=await b(s.options.validator,o.data));const i=t==="client"?s.options.client:s.options.server;return i?u(i,o,async d=>{if(t==="client"&&s.options.clientAfter){const c=await a(d);return u(s.options.clientAfter,c,v=>v)}return a(d)}):a(o)};return a({...n,headers:n.headers||{},sendContext:n.sendContext||{},context:n.context||{}})}function T(e){return{_types:void 0,options:{validator:e.validator,validateClient:e.validateClient,client:async({next:t,sendContext:n,...r})=>{var a;const o=await((a=e.extractedFn)==null?void 0:a.call(e,{...r,context:n}));return t(o)},server:async({next:t,...n})=>{var r;const a=await((r=e.serverFn)==null?void 0:r.call(e,n));return t({result:a})}}}}const H=globalThis,C=H.prisma||new m,E=()=>import("./c_1n1tvvr.mjs"),M=l().handler(x(j),async()=>{let e=new Date;return e.setHours(0),await C.event.findMany({where:{eventDate:{gte:e}},orderBy:[{eventDate:"asc"}]})}),S=w("/")({component:p(E,"component",()=>S.ssr)});function j(e){return M.__executeServer(e)}export{j as $,S as R,x as a,l as c,M as g,C as p};
